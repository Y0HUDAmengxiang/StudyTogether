# 一起学
项目不是最终完整版，仍然在做升级，项目文档算是自己学习的一个笔记吧，后期考虑加入日志一类的东西。
## 1.项目介绍

### 1.1.视频会议

#### 1.1.1.项目介绍

项目介绍：

- 本项目采用C++语言，C/S架构，使用TCP通信协议实现通信
- 服务器：服务器在Linux环境下采用 epoll+线程池模型 实现服务器的创建。
- 客户端：客户端则采用Qt框架，完成界面的绘制，以及利用Qt的信号和槽机制，完成数据的传递。
- 数据库：数据库则采用MySQL关系型数据库进行持久化存储
- 设计模式：！使用==中介者模式(how)==，==减少了类间的依赖降低了耦合(how)==，==符合迪米特原则(why)==提高了代码的复用性和拓展性

> 中介者模式在设计复杂系统时非常有用，它通过引入中介者对象来分离对象之间的交互关系，降低耦合度，提高系统的灵活性和可维护性。虽然它增加了一个额外的中介者对象，但通过集中控制交互，可以带来更清晰和可控的设计。

#### 1.1.2.服务器`Epoll`+线程池

<font color='red'>什么是IO多路复用，你为什么选择它？</font>

- <font color='red'>什么是多路IO复用技术</font>

  ==多路IO复用是一种在单个线程中管理多个输入/输出通道的技术。允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程==

- <font color='red'>说一下多路IO复用的优点</font>

  - 高效性：通过单个线程同时管理多个IO通道，减少了线程的创建和销毁开销，提高了系统的并发性能。
  - 节约资源：相比每个通道创建一个独立的线程，IO多路复用可以使用更少的线程来处理大量的IO通道，节约了系统资源。
  - 可扩展：由于使用了事件驱动模型，IO多路复用可以轻松地扩展到更多的IO通道，而不需要修改大量的代码。

- ==<font color='red'>说一下多路IO复用的缺点：</font>==

  - 不适用于CPU密集型的任务:多路IO复用适用于IO密集型任务，而对于CPU密集型任务，使用多线程或多进程模型可能更为合适。

**<font color='red'>IO多路复用的原理：</font>**

1. <font color='red'>多路复用：多路复用指的是一个线程可以同时监听多个IO时间的就绪状态，每个IO操作都需要一个独立的线程来处理，==当有大量的IO操作时，会导致线程的数量增加，从而带来线程切换和上下文切换的开销。而多路复用通过使用一个线程来监听多个IO事件，避免了线程数量的增加，减少了线程切换和上下文切换的开销。==</font>
2. <font color='red'>IO事件就绪通知：多路复用机制通过操作系统提供的系统调用（如select、poll、epoll等）来监听多个IO事件的就绪状态。当有任何一个IO事件就绪时，操作系统会通知应用程序，告知哪些IO事件已经准备好可以进行读取或写入操作。</font>
3. <font color='red'>非阻塞IO：多路复用机制通常与非阻塞IO配合使用。在非阻塞IO模型中，当一个IO操作无法立即完成时，不会阻塞线程，而是立即返回一个错误码或特定的状态，应用程序可以继续处理其他IO操作或其他任务，提高了系统的并发性能。</font>
4. <font color='red'>事件循环：多路复用机制通过事件循环来处理就绪的IO事件。事件循环会不断地监听IO事件的就绪状态，当有IO事件就绪时，会调用相应的回调函数来处理该事件。通过事件循环的方式，可以高效地处理多个IO操作。</font>

- 多路IO复用的实现：

  - select：

    select是最古老的多路IO复用机制，它<font color='red'>使用一个文件描述符集合来监听多个IO事件的就绪状态</font>。应用程序需要将需要监听的文件描述符添加到集合中，然后调用select函数进行监听。当有文件描述符就绪时，select函数会返回，并告知哪些文件描述符已经准备好进行读取或写入操作。然后应用程序可以通过遍历文件描述符集合来处理就绪的IO事件。

  - poll：

    poll是select的改进版本，它也使用一个文件描述符集合来监听多个IO事件的就绪状态。与select不同的是，poll不需要每次调用都将文件描述符集合传递给内核，而是使用一个pollfd结构体数组来传递。应用程序需要将需要监听的文件描述符和事件类型添加到pollfd数组中，然后调用poll函数进行监听。当有文件描述符就绪时，poll函数会返回，并告知哪些文件描述符已经准备好进行读取或写入操作。然后应用程序可以通过遍历pollfd数组来处理就绪的IO事件

  - epoll：
    epoll是Linux特有的IO多路复用机制，它使用一个内核事件表来管理和监听多个IO事件的就绪状态。应用程序需要将需要监听的文件描述符添加到内核事件表中，然后调用<font color='red'>epoll_wait函数进行监听</font>。当有文件描述符就绪时，epoll_wait函数会返回，并告知哪些文件描述符已经准备好进行读取或写入操作。与select和poll不同的是，epoll使用回调函数来处理就绪的IO事件，而不需要应用程序遍历事件列表。

==单单有强大的IO复用模型是远远不够的，还需要有强大的处理能力，这就需要加入线程池进行配合==

##### 1.1.2.1.服务器相关知识

- `Epoll`+线程池模型：

  Epoll模型也是经典的IO复用技术，整体的思路与工作模式和select没有任何的差别，也是由三部分组成(监听(监听集合),就绪(辨别就绪的socket)，处理就绪(不同的socket事件))

  struct epoll_event Node 监听节点类型

  Node.data.fd = sockfd 存储监听的socket

  Node.events = EPOLLIN | EPOLLOUT | EPOLLERR

  int epfd = epoll_create(int max) 参数为树的大小，返回值为监听树的描述符，可以通过次描述符操作监听树

  epoll_ctl(int epfd,int cmd,int sockfd,struct epoll_event* Node) 可以对监听树进行增删改操作

  - epfd:监听树描述符
  - cmd:操作方式-->EPOLL_CTL_ADD(添加节点),EPOLL_CTL_MOD(修改)，EPOLL_CTL_DEL(删除)
  - sockfd：节点索引
  - Node：即将操作的节点

- `Epoll`和Select对比(为什么选择`epoll`)

  1. `epoll`没有监听数量限制。理论上系统可以使用多少文件描述符，`epoll`可以监听多少个
  2. `epoll`不存在轮询问题，不用担心监听数量的增多开销变大，或处理能力变弱
  3. `epoll`并没有无意义的拷贝问题，因为他将监听集合直接创建在内核层，这样可以保证每个监听节点Node只拷贝一次并且只挂载一次。

- `Epoll`的巧妙设计：

  首先`Epoll`的设计非常聪明的避开了Select，poll的弊端，Select和poll随着多轮的使用需要频繁的把用户层的监听集合拷贝到内核层。这就会造成很大的系统开销，`Epoll`就很好的解决了这个问题，`Epoll`的监听树直接在内核层创建，所以我们只需要拷贝创建出来的某个监听节点就可以了，而且每个节点只拷贝一次，这样就避免了重复拷贝和挂载的开销。

  `Epoll`的内部设计：

  `Epoll`最经典的设计还有一个就绪链表，是一个双向的链表结构，用户层定义了就绪数组，当就绪的时候会将就绪的节点都抛出去，这些节点就是从链表拷贝出去的

  将双向链表的节点拷贝到就绪数组当中

  > :a:轮询是因为IO设备等待队列，主要借助网卡设备，会将这个消息发送给IO设备等待队列,如果有网络设备直接让我监听，就可以避免轮询

  `Epoll`为了避免轮询最聪明的一点就是直接与底层网络设备进行绑定，直接的去访问网络设备。那么是如何访问的？

  这就依赖于`Epoll`监听树的节点中的callback回调函数，他会把监听数据抽象成为一个`epitem`(监听项)与网络设备绑定，实现监听。callback最开始调用一次是完成了注册监听，当我们把`epitem`交个网卡的时候，`epitem`里边callback会再次生效，网卡设备会再次调用，此次的调用是为了把就绪的监听项传入到就绪链表，等待队列是为了挂起进程或线程单位的，我们现在使用的`epoll_wait`是阻塞的(阻塞必然会导致线程的挂起与执行)，进行阻塞监听，线程挂载到等待队列当中，在等待队列里的线程叫做等待线程，等待就绪，当网络设备的第二次callback被调用的时候(传出就绪完成)利用条件变量等待线程被唤醒。

  当前的==双向链表考虑到了多线程的问题。利用了一把旋转锁==，链表内的工作模式是遍历，遍历链表，有就绪就拷贝传出，当有拷贝数据项的时候，就进行到最后一步，将就绪拷贝到用户层的就绪数组当中。

  > <font color='red'>:a:旋转锁：</font>
  >
  > <font color='red'>什么是自旋锁？</font>
  >
  > 当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为自旋锁(spinlock)。
  >
  > ![](https://i-blog.csdnimg.cn/blog_migrate/d285074502d1038a982a909de3427aaf.png)
  >
  > <font color='red'>说一下自旋锁的原理？</font>
  >
  > 自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。
  >
  > <font color='red'>说一下自旋锁的优缺点：</font>
  >
  > 自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！
  >
  > 但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。

  当然了具有强大的网络监听能力还不够，更要有强大的数据处理能力，可以应对当量的数据请求，数据转发，只就需要线程池来处理高并发的数据场景。

##### 1.1.2.3.线程池技术：线程池是多线程容器，可以很好的使用和管理线程

**线程池技术的优势：**

1. 便于线程管理，可以根据线程池中的线程状态对线程进行扩容与缩减(线程数量取决于任务量)

2. 线程池中的线程有较好的可用性和复用性，此线程可以处理多次任务

3. 预创建线程，在线程池中囤积一部分待用线程，任务递达，立即处理

4. 线程池中的线程不会与特定的任务进行绑定

**线程池创建的五大原**

**线程池技术所应用到的技术：**

1. <font color='red'>线程</font>
2. <font color='red'>条件变量</font>
3. <font color='red'>互斥锁</font>
4. <font color='red'>生产者，消费者模型</font>

![image-20240724140918444](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202407241409571.png)

==**线程池的结构设计：**==

1. 提前创建一些线程

2. 采用生产者消费者模型

3. 有管理者对线程池检测，对线程池缩减和扩容

4. 保证线程安全

5. 线程要可以重用，不能让任务与线程绑定。

所以

1. 线程池头文件：线程池参数定义（缩减码，线程池开关，线程最大最小忙存活数量，任务的环形队列，环形队列的头尾最大当前，消费者管理者线程，条件变量，全局锁，任务接口）生产者消费者管理者函数，线程池初始化函数，回收函数，任务接口

2. 线程池初始化，需要参数`pthread_max,` `pthread_min`, `qmax`。三个需要申请空间，线程池，环形队列，存储消费者id。其他均做初始化

3. 生产者函数，线程池指针和任务指针参数

4. 消费者管理者函数 void* arg

5. 回收函数，线程池指针参数

**线程池API的作用以及实现流程：**

- `thread_pool_t* Thread_Pool_Create(int Max,int Min,int Que_Max)`

  线程池初始化方法：将线程池，任务队列，任务列表进行初始化，Max表示最大线程数，Min表示最小线程数(线程池初始线程数)，Que_Max表示队列中最大的任务量，初始化锁变量，初始化生产者，消费者，管理者线程。

- `Producer_Add_Task(pool_t* ptr,task_t ts):向任务容器中添加任务`

  先任务容器中添加一次任务，首先要确定当前的线程开关是否开着，如果开着，进行上锁处理，判断当前的任务量是否和队列的容量相等，如果相等了就产生阻塞等待，不再添加任务，当然了如果任务量没有满的话，就向其中添加任务，添加任务地址和任务参数，环形队列头指针偏移，任务量加一唤醒消费者去处理任务。

- `Customer_Job(void* arg):消费者在任务容器中提取任务进行线程工作`

  arg是线程池地址，需要先接一下 `pool_t * ptr = (pool_t*)arg`

  为了方便回收问题，将线程池中的线程设置成分离态，先上锁，判断任务队列当前任务数，如果当前任务队列为0的话，将其挂起到NOT_EMPTY变量，并且解锁。当有任务的时候，从尾索引获取任务和任务参数，任务量-1，环形队列为索引偏移计算，此时拿到了任务，开始执行，再开始执行之前一定要先解锁，并且将忙线程+1，因为我们无法确定Buines当中的任务量，如果任务量大，就会一直阻塞。唤醒生产者，去调用任务，调用完成之后将繁忙线程-1，但是也需要考虑一个问题，有可能在我挂起的时候，线程开关被人关了，所以当我们被唤醒的时候，先解锁，就直接将线程退出。

- `Manager_job(void* arg)`、

  关于管理者的讲究就变的非常多，需要考虑：

  - 关于扩容条件

    任务量大于可用线程数量

    让线程池可用线程保持特定数量，尽量避免任务递达后，现创建线程的情况

    当前存活线程数量假扩容数量不允许大于最大阈值

  - 关于适用CUSTOMER_TIDS数组问题

  - 关于缩减问题

    闲置线程是忙线程的2倍，进行缩减

    当前线程数量缩减两不允许小于最小阈值

  - 关于缩减方法

  - 关于使用CUSTOMER_TID数组问题

    线程扩容时需要使用tids数组保存新线程的id，如果数组中的值为0，可以直接使用，如果不为0，需要检测死亡，覆盖这一位

    就需要一个线程检测函数 IF_THREAD_ALIVE(pthread_t tid) 用来检测当前tids的线程是否存活

- 销毁没有什么好说的

##### 2.1.2.2.服务器的处理流程

在完成线程池的创建之后，我们正式介入服务器，将Epoll和线程池相结合起来

服务器的数据处理部分主要有分为三种请求：

1. 连接请求
2. 业务请求/数据请求
3. 断开请求

和用户比较近的是Epoll这一层，首先我们要准备一个内核监听集合上边挂载的都是监听节点(里边都包含着监听的socket，监听的事件，和回调函数)，还有一部分是epoll_wait函数进行阻塞监听，客户端无论发送那种请求，epoll都是可以监听到的，无非就是连接请求使server_fd触发读事件，数据请求是clientfd触发读事件，断开也是clientfd，服务器采用epoll完成监听，当前业务比较少，监听的有两类的socket，第一类serverfd，第二类clientfd，我们有一个业务列表，可以让不一样的就绪socket去处理不一样的业务，这就需要我们有一个任务列表，里边存储着不同的业务，可以对这个链表实现业务拓展，每一个socket绑定一个对应的业务，下面要做的就是监听到就绪，当业务就绪的时候，将当前业务添加到线程池当中，其实Epoll在当前扮演一个生产者的角色，不断的向线程之中添加不同的业务处理，消费者拿过去做处理。

我们对Epoll常用的连个操作是增加和删除，当有用户来连接了，用消费者去调用Accept，调用完accept会增加一个新的clientfd，这时就需要消费者对Epoll的监听树进行增加节点的操作，当结束监听事件的时候也同理。红黑树将采用多线程共享访问(添加，删除)

##### 1.1.2.4.服务器

![image-20240813175126884](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131751094.png)

![image-20240806083652136](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408060836237.png)

此部分分为网络的初始化，Epoll的初始化创建，Epoll的监听就绪并添加业务

- 网络初始化：

  ![image-20240805110233179](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408051102213.png)

- Epoll初始化创建：

  ![image-20240805110547712](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408051105745.png)

- Epoll监听：

  ![image-20240805111927402](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408051119443.png)

- Epoll同意连接：

  ![image-20240805113000192](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408051130235.png)

##### ==1.1.2.5.服务器的一些相关问题：==

- TPS：每秒钟请求的处理能力，更多时候他是包含QPS的

- QPS：每秒钟服务器的查询数量

  怎么算TPS和QPS？

  对业务处理的模块进行时间计算，了解处理能力

- 吞吐量：服务器主机的IO读写能力，CPU负载越高，吞吐量越低，负载低，吞吐高，所以服务器IO的处理能力，要看CPU负载

- 压力测试

- 负载测试：现在有效用户假设1w，用户发送了1w请求，服务器2s处理掉所有请求，处理时间为2s的前提下，逐步提高请求数量，查看时间变化，指定的时间区间可以处理最大业务数量，处理负载测试

- 压力测试：逐步提高测试并发连接数量和业务数量，直到服务器程序崩溃位置(记录主机性能指标，包含CPU，内存，磁盘，网络占用等等资源)，如果可以进行优化，优化后可以提升压力值。

- 响应时间

- 平均响应时间

- 最大线程数是怎么设计的，怎么求出来的

  

- 你的系统下最大线程数是多少

  

- 当你的服务器一下子来了一大堆连接应该怎么处理

  

##### 1.1.2.6.项目服务器处理数据的流程

偏移量计算：

![image-20240809074737681](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408090747755.png)

![image-20240806091924849](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408060919894.png)

首先当一个信息从客户端发出的时候，服务端的Epoll_wait启用阻塞监听等待事件的发生(循环进行)。

当事件为请求连接的事件的时候，进入请求连接事件处理：

> :airplane:**连接事件请求处理：**
>
> 服务端作为生产者将连接处理请求加入任务队列当中(因为当前的任务队列采用的是多线程访问，需要用到互斥锁),线程池中的消费者线程将任务从任务队列当中取出进行执行，到服务端同意连接，将客户端监听节点设置挂载到监听树上去，开始启用业务事件的监听。

当时事件为数据请求的时候：

> :ok:**数据请求处理：**
>
> 与连接请求不同的是当数据递达的时候，监听到事件为非连接请求的时候，将进入到非连接请求事件的处理，也就是正式的业务响应，接受事件采用线程池，多线程处理，由于使用EPOLLONESHOT避免同一套接字的线程并发问题，服务端作为生产者，将接收到的事件(也可以称之为任务)放入到线程池当中，由多线程消费者把任务取出进行处理。

==接受和处理分离：先接收包的大小，在接受包内容，然后将包内容发送到其他线程处理==

1. 服务端接收到数据后，通过判断是<font color='red'>recv任务</font>。

   ![image-20240813155926188](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131559264.png)

2. 将任务放入到线程池任务队列中，并通过条件变量唤醒消费者线程，消费者将任务从任务队列内取出。

   ![image-20240813155954082](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131559115.png)

   ![image-20240813160007468](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131600498.png)

   ![image-20240813160025129](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131600167.png)

3. 根据函数头确定工作内容recv_task，先使用recv进行接收，由于socket是非阻塞的，所以在接收时也是非阻塞的，需要循环接收，将数据从内核缓冲区拷贝到用户缓冲区后，将数据作为任务添加到线程池任务队列中。

   ![image-20240813160528335](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408131605382.png)

4. 接收和处理分离，优点不会由于处理任务而导致recv阻塞，让recv从内核缓冲区读取速度更快，数据接收完事后调用生产者函数，将处理任务放入线程池任务队列上，再通过环境变量唤醒消费者。

5. 消费者将任务从任务队列内取出，根据函数头确定工作内容Buffer_Deal，在Buffer_Deal内调用回调函数，找对对应的任务处理函数。

##### 1.1.2.7.服务端功能

###### 1.1.2.7.0.packdef

- 用于边界值的设定
- 数据库信息的宏
- 自定义的协议和协议头
- 还有一些返回的结果

###### 1.1.2.7.1.block_epoll_net

<font color='cornflowerblue'>此部分主要分为数据缓存结构体的定义，将原生的Map修改为MyMap，将原有的事件结构重新进行封装，封装为自己的事件结构，Epoll网络模型</font>。

> :a:为什么epoll?
>
> 同步阻塞多线程，具有编程简单，问题少等优点，但不足是无法处理过多的客户端
>
> 多路IO复用模型中较为优秀的epoll，可以解决上边的问题，并且处理网络请求的效率比较高。
>
> :a:为什么使用阻塞socket
>
> 这里的阻塞socket，是指客户端accept客户端连接后，返回的套接字。
>
> :a:同步IO和异步IO的区别：
>
> - 同步可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。。
> - 异步指的是执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。
>
> ![image-20240806090143624](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408060901669.png)
>
> 异步IO就是系统完成数据从内核缓冲区到用户缓冲区的拷贝，并发送一个信号或通知
>
> 同步IO就是需要代码实现数据从内核缓冲区到用户缓冲区的拷贝

###### 2.1.2.7.2.Thread_Pool

<font color='red'>此部分主要负责线程池的定义，以便于更好的使用，其中包括任务队列的定义，线程池中生产者消费者的定义</font>

> :a:任务队列的构成：循环队列里主要包括任务数组，队列头指针，队列尾指针，为了保证数据安全访问，我们还添加了，读写互斥锁(避免多线程并发)，条件变量等，条件变量主要负责(队列空的时候，消费者等待，队列满的时候生产者等待)。
>
> :a:线程的基本工作流程：
>
> 1. 程序开始执行的时候创建最小的线程数保存在线程池当中处于阻塞等待状态
> 2. 某线程中创建任务，队列未满时投递任务，同时发送条件变量信号，队列满则等待
> 3. 队列里有任务投递后，一个空闲线程收到条件变量信号，从队列尾取出任务并执行。
> 4. 执行完成后回来继续等待条件变量信号。
>
> :a:线程池管理：
>
> 1. 创建一个线程用于管理线程池，每隔一段时间产看忙碌的线程数或者存活的线程数
> 2. 在空闲线程占比不足20%时，创建一些线程
>
> 3. 在空闲线程占比超过80%时，销毁一些线程。
>
>   <font color='red'>关于线程的阈值可以根据不同的应用场景自行决定</font>

###### 1.1.2.7.3.MySQL

<font color='cornflowerblue'>此部分包括建立连接，查询，更新，断开连接，与以往不同的是，这次我们所使用的MySQL加入了互斥锁，在多线程的模式下，以保证数据更加安全的处理</font>

###### 1.1.2.7.4.clogic

==此处为真正的业务处理模块，包括协议映射，数据的发送，注册请求的处理，登录的处理，创建房间的处理，加入房间的处理，离开房间的处理，音频帧请求的处理，视频帧请求的处理，音频注册，视频注册==

##### 1.1.7.8.服务端相关数据

1. 服务器压力测试：最大连接数大概是16300多~14100多

   使用websocket进行测试，tcp最大的连接数和设置的文件描述符有关，我们见描述符设置的是65535.

2. 最大线程数

   创建线程的pid类型是pthread_t，但他实际上的类型是short，所以线程最大创建数不能超过short的最大众32768

   但是我们知道线程是有一定的大小的，通过pthread_attr_getstacksize获取了我当前线程栈默认大小为8m，虚拟内存中1G是用户空间，剩余3G是内核空间，所以3G的内核空间大概能创建384个下成。

3. 一个进程中最多可以有多少个线程

   我们知道了创建一个线程会占用多少内存，这取决于分配给线程的调用找大小，可以用uimt-s命令来查着大小，显示的单位是KB(一股常见的有10M或者是8M，也可以临时修改)。我们还知道，一个进程的虚拟内存是4G，在Linux32位平台下，内核分走了1G，留给用户用的只有3G，于是我们可以想到，创建一个线程占有了10M内存，总共有3G内存可以使用。于是可想而知，最多可以创建差不多300个左右的线程。


##### 1.1.2.10.关于epoll水平触发和边缘触发的区别

了解水平触发和边缘触发的背景知识---->针对于io多路复用(不能为连接之类的设置，只能为Epoll)，像select和poll只有水平触发，epoll默认水平触发，可以设置边缘触发。

==io多路复用是用来帮助我们检测这个io是否准备就绪==，他只能检测是否就绪，仍然需要通过io函数处理对应的io，就绪是通过两种事件形式告知的，一个是可读事件触发条件，一个是可写事件触发条件

水平触发:只要满足io就绪条件就会触发

并没有处理，下一次epoll_wait依然可以拿到就绪事件

我们没有处理完全，下一次Epoll_wait依然可以拿到这些就绪事件

边缘触发:新的io就绪事件到来就触发一次

没有处理，下一次epoll_wait就拿不到就绪事件

没有处理完全，下一次epoll_wai她就拿不到就绪事件

首先呢我们所提到的水平触发模式和边缘触发模式，<font color='red'>两种不同的模式影响的是接受事件的行为</font>

- 水平触发模式(LT)：也被称之为负责模式，他会持续向上层发送处理通知直到此事件处理完完成

  水平模式下，如果上次的就绪事件未处理完毕，不允许用户执行epoll_wait进行新一轮监听，调用立即返回，返回值为未处理的就绪事件数量。epoll_wait检测到事件发生后通知了应用程序 -> 应用程序可以不立即处理该事件。 下一次调用epoll_wait时，还会再次向应用程序通知此事件，直到该事件被处理

  通俗的讲，水平触发，只要有数据，epoll_wait()就会一直返回

- 边缘触发模式(ET)：也被称之为非负责模式，

  边缘触发模式下，如果产生就绪，epoll会发送一次处理通知，但是有且仅有1次，无论用户是否处理就绪事件都与epoll无关
  即使用户未处理第一轮的就绪事件， 可以随时执行

  如果数据没处理完，并且这个 fd 没有新的事件，那么再次 epoll_wait() 的时候也不会有事件上来。epoll_wait检测到事件发生后通知了应用程序 ->应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。

- EPOLLONESHOT：

  我们都知道EPOLL有两种触发方式一种是水平触发，一种是边缘触发，前者只要存在事件就会不断地出发，直到这个时间处理完成，后者只要触发一次相同事件，或者说只在非触发到触发两种个状态转换的时候才会触发。

  这就会出现一种情况，如果多线程在处理个SOCKET事件到来，数据开始解析，这时候这个SOCKET又来了同样一个这样的事件，而你的数据解析尚未完成，那么程序会自动调度另外一个线程或者进程来处理新的事件，这造成一个很严重的问题，不同的线程或者进程在处理同一个SOCKET的事件，即使在ET模式下也有可能出现这种情况！！

  第二种方法就是本文要提到的EPOLLONESHOT这种方法，可以在epoll上注册这个事件，注册这个事件后，如果在处理写成当前的[SOCKET](https://so.csdn.net/so/search?q=SOCKET&spm=1001.2101.3001.7020)后不再重新注册相关事件，那么这个事件就不再响应了或者说触发了。要想重新注册事件则需要调用epoll_ctl重置文件描述符上的事件，这样前面的socket就不会出现竞态这样就可以通过手动的方式来保证同一SOCKET只能被一个线程处理，不会跨越多个线程。

#### 1.1.3.客户端(Qt)

客户端这边有关业务部分当然没什么好说的，也没有服务器那么复杂，但是有一些我们运用到的机制和所使用到的东西我们是必须要有深入了解的。

##### 1.1.3.1.MD5加密算法

- **MD5概述：**

  MD5加密是消息摘要算法第五版，它是一种消息摘要算法，属于哈希算法的一种。

- MD5的主要特点：

  不可逆，相同的数据的MD5值肯定一样，不同数据的MD5值不一样

- MD5的性质：

  1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的（相当于超损压缩）。

  2. 抗修改性：对原数据进行任何改动，哪怕是只修改1个字节，所得到的MD5值都会天差地别。
  3. 容易计算：从原数据计算出MD5值很容易就可以计算出来。
  4. 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。注意这里是非常困难，并不是一定找不到。
  5. 强抗碰撞性，想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。注意这里是非常困难，并不是一定找不到。

- **MD5的破解：**

  MD5有不可破解的特点，但是不可逆，并不代表他并不是无法破解

  某些MD5破解网站，专门用来查询MD5码，原理是它通过把常用的密码先进行MD5处理，然后将数据存储起来，然后再跟需要查询的MD5结果匹配，这时就有可能通过匹配的MD5值得到明文数据，所以有些简单的MD5码是可能反查到加密前的明文的。

- **MD5防破解：**

  - 多重加密：

    所谓多重加密，其实 就是把要加密的原文加密成MD5密文，然后再一次将MD5密文加密成MD5密文，多试几次，一般3次以上，但是这种加密只是不容易破解，增加可破解的时间成本

  - ==加盐加密：==

    这种办法就是明文加密过程中，把盐（其实就是一小截字符串，例如abc）和明文拼接到一起加密。因为每个帐号的盐值不同，同样明文，加密出来的密文都不一样，这样帐号安全性就大大提高了。

- ==MD5的用途：==

  1. 密码存储：

     处于安全考虑，所有的原生密码不能直接存储到数据库中，以防数据泄露导致许多问题出现，因此，会将明文密码经过[MD5加密](https://so.csdn.net/so/search?q=MD5加密&spm=1001.2101.3001.7020)后存储到数据库中。

  2. 一致性校验：

     下载文件的校验码，比如双方约定的字符串或者文件，发送方可提供文件的同时，也提供MD5结果，用于接收方接收后对文件重新 MD5得出结果做对比，就知道文件是否下载完整，或者传输过程中有无被篡改等。

##### 1.1.3.2.音频知识

![image-20240807190644418](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408071906565.png)

本项目在音频部分使用的组件是Qt自带的 `QAudioInput` 和 `QAudioOutput` 使用`speex编解码器`

**前言**

本段主要介绍目前音频编码格式，编码格式包括无损压缩和有损压缩，无损压缩包括PCM,APE,FLAC,ALAC.而蓝光中的杜比AC3的TrueHD，和DTS中的DTS-HD也属于无损压缩。

<font color='cornflowerblue'>PCM：脉冲编码调制，是将模拟信号转化为数字信号的一种方法</font>

声音的转换的过程为：

1. 先对联系的模拟信号按照固定频率周期采样
2. 将采样得到的数据按照一定的精度进行量化，量化后的信号和采样后的信号差值叫做量化误差
3. 将量化后的数据进行编码存储，最终将模拟信号转换为数字信号

==**PCM-->未经压缩的原始数字音频信号**==

最原始的音频数据存储方式

特点:

音质还原最好，声音基本无损

软件支持最好，便于音频编辑

文件体积最大，不利于网络传输

==PCM（脉冲编码调制）是一种将模拟信号转换为数字信号的基本方法，但不能简单地说它是“最原始的数据帧”。==

音频采样频率：

 指每秒钟取得声音样本的次数。声音其实是一种能量波，因此也有频率和振幅的特征，频率对应于时间轴线，振幅对应于电平轴线。波是无限光滑的，弦线可以看成由无数点组成，由于存储空间是相对有限的，数字编码过程中，必须对弦线的点进行采样。同一时间内1秒钟采样越多，音频信息就更丰富，采样频率越高，声音的质量也就越好

**MP3**

MP3是一种音频压缩技术，其全称是动态影像专家压缩标准音频层面3

MP3音频压缩包含编码和解码两个部分。编码是将[WAV](https://so.csdn.net/so/search?q=WAV&spm=1001.2101.3001.7020)文件中的数据转换成高压缩率的位流形式,解码是接受位流并将其重建到WAV文件中。

**ACC:**

高级音频编码。

相对于mp3，音质更佳，文件更小；
支持多种声道组合，提供优质的音质；
文件封装格式：
.aac：使用MPEG-2 AAC编码的容器，传统的AAC编码
.mp4：使用MPEG-4 AAC编码的容器；
.m4a：其本质与音频MP4相同，苹果公司为区别视频mp4故改名为m4a，这个扩展名变得流行了。

==**SPEEX：**==

Speex是一套主要针对语音的开源免费，无专利保护的音频压缩格式。
Speex是基于CELP并且专门为码率在2-44kbps的语音压缩而设计的。
文件封装格式：
.ogg：

- ==speex--->编解码器==

  speex是近年来开发出的一套功能强大的语音引擎，能够 。它不仅提供了基于码激励线性预测（CELP）算法的编/解码模块，而且在其最新发布的版本中还提供了声音预处理和声学回声消除模块，为保障IP网络中的语音通信质量提供了技术手段。

  - 为什么使用：
    1. 开源，纯C开发，跨平台，兼容ARM，编译简单
    2. 占用比特率小
    3. API使用比较简单
    4. 支持2.15~44.2kbps
    5. 采样率支持:8khz,16khz,32khz
    6. 跨平台

- 窄带，宽带，超宽带(采样格式)

  - 窄带：人声主要信息频段（发声：300Hz-3400Hz），覆盖中低频。语义清楚但听感发闷，主要用于以前的有线电话时代或无线2G。--->1帧20ms
  - 宽带：发声极限（通话够用），听感基本正常清晰，主要在无线3G
  - 超宽带：普通音乐，称为高清语音，听感基本达到面对面交流体验。4G/5G主

##### 1.1.3.3.视频知识

本项目视频和桌面采集用的都是opencv库，opencv是一个开源的计算机视觉库，OpenCV用来读取视频很方便，可以很方便的读取文件或者获取到摄像头权限之后，读取摄像头的实时视频流。而且他的上限非常的高，后来项目中做的人脸识别，和通过人脸识别往人脑里放贴图都用到了opencv

###### 1.1.3.3.1.YUV和RGB

YUV，RGB是色彩空间模型，平常所说的BMP,PNG，JPEG是文件的存储形式，而YUV是音频(编解码)最常用的格式

- YUV数据格式：

  YUV有两种分类方式，即空间-间，空间-内，空间-间的划分主要体现在Y,U,V的比例不同,空间-内的划分方式主要体现在YUV的比例一定，存储格式不同

- RGB:即red,green,blue三色存储空间，因为音视频主要用的是YUV的色彩空间YUV 格式更便于在不同的色彩空间之间进行转换，这对于视频处理和编码非常重要。

为什么用YUV而不用RGB：

- YUV 格式在视频压缩中具有更高的效率
- 降低带宽需求：YUV 格式允许对色度信息进行较低分辨率的采样
- 色彩空间转换：YUV 格式更便于在不同的色彩空间之间进行转换，

YUV在视频处理、压缩和传输方面具有一定的优势。

**<font color='red'>总结：OpenCV更加适用于实时的一些操作，也就是与摄像头有关的</font>**

>  帧：
>
>  流媒体领域，『流』很重要，『流』的基本元素『帧』同样重要。
>  原因在于：
>
>  对于视频编码/压缩而言，它的核心是采用尽量小的空间存储一组时间上连续的帧数据；
>  而对于视频解码而言，就是把被编码/压缩后的一组帧数据尽量恢复成原来的样子。
>
>  能够被100%恢复的编码/压缩算法称为无损压缩，反之称为有损压缩（虽然无损压缩是最理想的，但是在很多实际场景中为了追求高压缩率，比如为了减小网络带宽压力，常常不得不选择有损压缩）。
>  帧：可以联想成我们平时看到的一幅幅“图像”，只不过我们平时接触的图片是RGB格式的，而视频帧通常是YUV格式的。
>  <font color='red'>帧为什么采用YUV格式？YUV是什么？</font>
>
>  1. 在达到最大压缩率的情况下，能够保证对人眼感知的失真度最小。YUV的三通道中，其中"Y"表示明亮度。而"U"和"V"表示的则是色度，人对UV的感知度最低，一次可以极大比例地压缩UV两个通道的数值
>
>  2. 为了向前兼容黑白电视。
>
>  I帧(关键帧)是能独立播放的一帧图像，数据量是最大的。--->主要帧
>
>  P帧(前向预测帧)需要根据前一个I帧或P帧计算所得，数据并不完整，数据量比I帧少，视频中大多数都是P帧--->存储与主要帧有发啊生变化的数据帧的位
>
>  B帧(双向预测内插编码帧)需要根据前一个和后一个I帧或P帧计算所得，数据最不完整，数据量是最少的。---->参考前边的I帧和后边的P帧，达到更小的存储空间双向参考
>
>   IDR帧：第个I帧，是立刻刷新，使错误不导致传播，
>
>  GOP：两个I帧之间是一个图像序列，一个GOP包含一个I帧
>
>  > GOP的大小会对图片产生一定的影响，较小的GOP意味着I帧出现的频繁，P帧和B帧是基于I帧的到的
>  > GOP过小时，对于视频中的随机访问（如跳转播放）和错误恢复更有利，因为 I 帧出现频繁，能更快地获得完整的图像信息，从而在一定程度上保证图片质量。
>  >
>  > 然而，如果 `Gop` 过大，I 帧间隔较长，在网络传输出现错误或丢包时，可能会导致较长时间的图像质量下降，影响整体观感。
>  >
>  > 当然了除了GOP 一些相机的参数和本身照片质量都会影响GOP的数值
>
>  <font color='red'>PTS(Presentation Time Stamp)：PTS主要用于度量解码后的视频帧什么时候被显示出来</font>--->编码的一个顺序想要去解码，把解码时间的依次顺序送入到解码器
>
>  <font color='red'>DTS(Decode Time Stamp)：DTS主要是标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码</font>--->原始采集的一个顺序
>
>  ![image-20240807192235048](https://fanyu12233.oss-cn-beijing.aliyuncs.com/img/202408071922124.png)
>
>  > 在理想情况下，对于给定的媒体帧，其显示时间戳（PTS）应该大于或等于解码时间戳（DTS）。这是因为在实际的播放过程中，你需要先解码帧（在DTS指定的时间），然后再显示帧（在PTS指定的时间）。所以，通常PTS会大于或等于DTS。
>  > 然而，这并不是一个绝对的规则。在某些特殊的编码情况下，例如使用B帧（双向预测帧）的视频编码，可能会出现PTS小于DTS的情况。这是因为B帧的解码需要依赖于其前后的帧，所以它可能会在其显示之前的帧被解码，这就导致了PTS小于DTS。
>  > 至于两者的差值，它并不直接等于解码时间。解码时间实际上是由解码器的性能和复杂性决定的，和PTS和DTS的差值没有直接关系。PTS和DTS的差值更多的是反映了帧的解码顺序和显示顺序的差异。
>
>  GOP(Group of Pictures)：顾名思义，就是一组图片，在实际操作中，就是一组完整的视频帧，也就是说一个GOP拿出来，必须能够完整的播放、显示。那GOP就可以推断出来，必须是以I帧开头，这样后面的P帧和B帧才能跟据前向参考帧进行解码显示。
>
>  IDR frame(Instantaneous Decoding Refresh)：Instantaneous Decoding Refresh，及时解码刷新。立刻刷新，所以IDR帧必须是一个I帧，但是I帧不一定是IDR帧，这个帧出现的时候，是告诉解码器，可以清除掉所有的参考帧，这是一个全新的序列，新的GOP已经开始。
>
>  帧率（FPS）: 设置为30帧 fps 视频其实就是一张张图片连续播放。那么就涉及到一个问题，一秒钟播放多少张图片？也就是一秒钟多少个数据帧，这个数字就是帧率。日常使用中，我目前见到的固定帧率的情况比较多，比如市面上一些智能摄像头之类的。超过 24 FPS 时，人眼通常就会将其感知为连续流畅的运动。
>
>  码流(BPS):或者称为码率，只针对视频数据，单位时间内视频数据量大小，一般以秒为单位(KB/S)。 300~500kbz左右
>
>  码率=视频数据大小/视频时间长度。 
>
>  对于直播之类的计算，码流=视频传输数据量/传输时间。
>
>  在直播中，两种方式计算的码流应该是近似相等的，否则就会出现类似延时，卡顿等情况。
>
>  :a:编码格式的作用:
>
>  一个视频文件实际上分三层:**封装，编码，基础数据**，编码是为了压缩数据，限制文件的大小，以视频为例，视频是由一帧一帧图像组成的，一帧图像的大小是由基础数据格式决定的，视频的基础数据格式一般为色彩空间模型，**编码的过程是由编码格式决定的**，每个编码格式对应不同的压缩/解压缩算法，每个编码格式也对应不同的编码器/解码器，如果播放器不支持某个编码格式的话是播放不出来的。，一般只有对**视频文件大小产生影响的基础参数**才会**作用在编码阶段**，如码率、最大码率等。编码阶段会按这些参数限制文件大小，但同时也可能会产生有损压缩，影响画面质量。
>
>  :a:H264
>
>  H264是最常用的视频编码格式，这里的**视频指的是图像**。H264并不能处理音频数据。
>
>  具体的压缩算法是不需要搞清楚的，但需要清楚对应的H264特殊概念，I帧、P帧、B帧、GOP。
>
>  :a:为什么选择H264不选择H265
>
>  相同的视频H265编码的文件会比H264编码的文件小很多，一些时候甚至接近50%。所以理论上，在相同带宽的前提下，H265的在线视频、直播流会拥有更高的画质，相同画质的情况下，H265也能更节省带宽/流量。但这是建立在编码、解码计算量为代价的，也就是说，播放H265视频，会比H264视频更消耗性能。
>
>  <font color='red'>这是H264、H265最大的区别，H265比H264拥有压缩率更高的压缩算法。但同时，也损耗更多的性能，H264、H265的选择，更多是根据实际场景下，容量、带宽对比用户、服务器性能，哪个更为重要的考量。</font>

##### 1.1.3.4.音视频的处理流程

音视频通信是指将音频和视频数据从一个端点传输到另一个端点的过程。通常，音视频通信流程包括音视频采集、编码、传输、解码和渲染五个主要环节。

<font color='red'>音视频采集：</font>音视频采集是指将[麦克风](https://so.csdn.net/so/search?q=麦克风&spm=1001.2101.3001.7020)、摄像头等音视频设备中的模拟信号转换成数字信号的过程。这个数字信号可以是PCM音频数据或者视频帧。在采集过程中需要确定采样率、采样精度等参数。

<font color='red'>音视频编码：</font>音视频编码是指将数字信号转换成可传输或存储的格式的过程。常见的音视频编码格式有H.264、H.265、AAC、MP3等。编码后的音视频数据可以更有效地进行传输和存储。

1. 打开摄像头开始采集，采集完压缩，序列化之后，发送出去

2. opencv采集摄像头，格式会由BGR转化为rgb24，就是每个像素用24比特位表示，占3个字节rgb888即使红绿蓝，对应每个颜色存储时8位

3. 以我的屏幕为例子分辨率是1600*900=1440000像素点，一个点三个字节换算就是4320000字节换算就是4.12mb，摄像头是640x480就是307200个像素点换算完就是900kb

4. 我们规定帧率是25fps就是一秒25帧画面，换算下来就是100mb每秒，所以必须进行压缩

5. .本项目采用的JPEG格式进行压缩，测试可知可以将摄像头的900kb压缩到10-20kb不等(如果黑色多一些，数据量就会少一些)，所以一秒25帧的数量量大概在250-500kb左右，如果是桌面采集，需要的数据量更大

6. JPEG格式只支持YUV(明亮度色度)颜色模式，不支持RGB颜色模式，所以还要进行颜色模式转换。

   DCT变换:将图像信号在频率域进行变换，分离出高频和低频信息的处理过程。

   量化:编码使用的都是整数，而DCT转换的数据都是近似值，所以量化后会和原始数据有差异，这也是造成图像压缩后失帧的原因。

   编码:编码采用两种机制:一是0值的行程长度编码:二是熵编码

7. 后来采用的H.264编码格式，资料显示编码率可达102比1。

##### 1.1.3.3.信号和槽机制

在Qt中用户和Qt控件的每一次交互过程都称之为一次事件，Qt中的所有控件都具有接收信号的能力，⼀个控件还可以接收多个不同的信号。对于接收到的每个信号，控件都会做出相应的响应动作。 

信号和槽是Qt特有的消息传输机制，它能将相互独立的控件关联起来。

- 信号的本质

  信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时Qt对应的窗口类会发出某个信号，以此对用户的操作做出反应。因此，信号的本质就是事件

- 槽的本质

  槽（Slot）就是对信号响应的函数。槽就是⼀个函数，与一般的C++函数是一样的，可以定义在类的任何位置（public、protected或private），可以具有任何参数，可以被重载，也可以被直接调用（但是不能有默认参数）。槽函数与一般的函数不同的是：槽函数可以与信号关联，当信号被发射时，关联的槽函数被自动执行

:a:说明

- 信号和槽机制底层是通过函数间的相互调用实现的，每个信号都可以用函数表示，及信号函数，每个槽也可以用函数表示，即槽函数
- 信号函数和槽函数通常位与某个类当中，和普通成员函数相比，
- 信号函数用signals关键字修饰，槽函数用public slots、protected slots或者private slots修饰（使用普通成员函数的方式修饰也可）。signals和slots是Qt在C++的基础上扩展的关键字，专门用来指明信号函数和槽函数；信号函数只需要声明，不需要定义（实现），而槽函数需要定义（实现），若一个类要使用信号和槽机制，必须在类中添加Q_OBJECT这个宏

##### 1.1.3.4.程序的正式处理流程

项目客户端基于Qt框架的绘制，基于Qt信号槽的机制，使得数据可以高效的传输

###### 1.1.3.4.1.注册

当我们启动程序的时候，会显示出来一个注册界面，其中注册界面包括，手机号，昵称，密码和确认密码，我们将这些信息全部输入的时候，点击注册，这时Qt会获取空间上的数据，通过Q_EMIT绑定的对应的槽函数发送到中介者类，中介者类开始对这些数据进行合法性判定，首先在手机号不为空的前提下

###### 1.1.3.4.2.登录

客户端在昵称和密码填写完成之后，点击登录按钮，系统获取文本框当中的文本，密码进行MD5加密后，通过信号发送到中介者当中，会触发该事件的槽函数会先判断当前用户是否在某个房间内，如果不在就将创建房间请求发送给服务器

###### 1.1.3.4.3.创建会议

首先当用户点击创建会议的时候，会向请求发送到服务器，服务器会判断当前用户是否在会议当中，如果在会议当中，将无法创建房间，如果没在房间内，会生成一个0~99999的随机数作为房间号，将房间号存储到map和list的映射当中，返回到客户端，将该有的控件都设置到界面中，创建会议成功

###### 1.1.3.4.4.加入会议

当用户点击加入房间的时候，服务器会判断当前用户是否在房间内，如果在房间内，将会返回加入房间失败，如果当前用户没有在房间内的话，就会弹出输入房间id的窗口，房间id正确将会加入房间，当加入房间的时候，服务器会把当前用户的空间加入到对应的链表当中，并且把自己的信息发送给房间以内出自己以外的所有用户，当然了，其他用户的信息也会发送给自己，并且完成相应的设置。

###### 1.1.3.4.5.打开音频

发送SIG_audioStart信号，触发slot_startAudio槽函数，函数内调用m_pAudio_Read->start()函数，开始捕捉音频，每640字节发送一次，触发信号和槽Audio_Read::slot_readMore函数将数据从音频设备拷贝出来，通过SIG_audioFrame发送个slot_audioFrame槽函数slot_audioFrame槽函数将音频数据封包，包括用户id，房间号，时间戳发送个服务端，服务端接收到数据后，通过判断是recv任务，将任务放入到线程池任务队列中，并通过条件变量唤醒消费者线程，消费者将任务从任务队列内取出，根据函数头确定工作内容recv_task先使用recv进行接收，由于socket是非阻塞的，所以在接收时也是非阻塞的，需要循环接收，将数据从内核缓冲区拷贝到用户缓冲区后，将数据作为任务添加到线程池任务队列中接收和处理分离，优点不会由于处理任务而导致recv阻塞，让recv从内核缓冲区读取速度更快，数据接收完事后调用生产者函数，将处理任务放入线程池任务队列上，再通过环境变量唤醒消费者，消费者将任务从任务队列内取出，根据函数头确定工作内容Buffer_Deal，在Buffer_Deal内调用回调函数，对对应的AudioFrameRq任务进行处理AudioFrameRq函数判断当前房间号是否存在，获取房间成员列表，将音频数据原封不动转发给房间内其他成员客户端的RecvData接收到服务器的信息，当接收完对端的信息后，调用DealData函数DealData发送SIG_ReadyData信号，触发slot_dealData槽函数进行数据处理slot_dealData槽函数根据协议绑定表，和从数据中获取的协议头，调用slot_dealAudioFrameRq函数slot_dealAudioFrameRq函数会获取数据中的房间id，用户id以及音频数据，调用 aw->slot_net_rx(ba);将音频数据写入声卡设备之后进行播放判断当前音频状态是否为静音，通过speex内置函数对音频进行编解码压缩，通过SIG_audioFrame发送个slot_audioFrame槽函数，slot_audioFrame槽函数将音频数据封包，包括用户id，房间号，时间戳发送个服务端，服务端接收到数据后，通过判断是recv任务，将任务放入到线程池任务队列中，并通过条件变量唤醒消费者线程，消费者将任务从任务队列内取出，根据函数头确定工作内容recv_task，先使用recv进行接收，由于socket是非阻塞的，所以在接收时也是非阻塞的，需要循环接收，将数据从内核缓冲区拷贝到用户缓冲区后，将数据作为任务添加到线程池任务队列中，接收和处理分离，优点不会由于处理任务而导致recv阻塞，让recv从内核缓冲区读取速度更快，数据接收完事后调用生产者函数，将处理任务放入线程池任务队列上，再通过环境变量唤醒消费者，消费者将任务从任务队列内取出，根据函数头确定工作内容Buffer_Deal，在Buffer_Deal内调用回调函数，对对应的AudioFrameRq任务进行处理

关闭音频

关闭音频，触发SIG_audioPause信号，会被slot_pauseAudio槽函数捕捉，该函数调用m_pAudio_Read对象的pause函数，将音频想想过数据和资源进行关闭销毁

###### 1.1.3.4.6.打开视频

点击房间界面视频按钮，判断当前控件是否被勾选，被勾选就是打开视频，反之关闭视频

打开视频使用opencv打开摄像头捕捉图片，之后通过slot_getVideoFrame对采集过来的图片进行格式转换，之后调用信号和槽，将图片数据发送给服务端，服务端接收后，放到任务队列，再从任务队列中取出，通过回调函数，将图片转发给房间内的其他人

关闭视频

关闭摄像头，回收视频资源

点击房间界面桌面按钮，判断当前控件是否被勾选，被勾选就是打开桌面捕捉，反之关闭桌面捕捉打开屏幕捕捉客户端获取屏幕截图，缩放改变尺寸，将图像发送给服务器，服务器取出任务后，将数据原装转发给房间列表内其他成员

关闭屏幕捕捉

关闭屏幕捕捉，回收对应数据

###### 1.1.3.4.7.共享桌面

点击房间界面视频按钮，判断当前控件是否被勾选，被勾选就是打开视频，反之关闭视频

打开视频使用opencv打开摄像头捕捉图片，之后通过slot_getVideoFrame对采集过来的图片进行格式转换，之后调用信号和槽，将图片数据发送给服务端，服务端接收后，放到任务队列，再从任务队列中取出，通过回调函数，将图片转发给房间内的其他人

###### 1.1.3.4.8.退出房间

用户在房间界面点击X或者退出房间按钮，触发closeEvent函数，之后放松SIG_close信号，触发slot_quitroom函数，slot_quitRoom函数，将当前用户id，昵称，房间号打包发送给服务器，之后关闭当前用户音频，视频，屏幕捕捉，将用户控件从房间控件上清除，服务端接收到数据后，通过判断是recv任务，将任务放入到线程池任务队列中，并通过条件变量唤醒消费者线程，消费者将任务从任务队列内取出，根据函数头确定工作内容recv_task

先使用recv进行接收，由于socket是非阻塞的，所以在接收时也是非阻塞的，需要循环接收，将数据从内核缓冲区拷贝到用户缓冲区后，将数据作为任务添加到线程池任务队列中

接收和处理分离，优点不会由于处理任务而导致recv阻塞，让recv从内核缓冲区读取速度更快，数据接收完事后调用生产者函数，将处理任务放入线程池任务队列上，再通过环境变量唤醒消费者，消费者将任务从任务队列内取出，根据函数头确定工作内容Buffer_Deal，在Buffer_Deal内调用回调函数，对对应的LeaveRoomRq任务进行处理，LeaveRoomRq函数先拆包，获取当前房间列表内的成员，将自己退出房间信息发送个房间列表内的成员，之后更新房间列表成员

 
